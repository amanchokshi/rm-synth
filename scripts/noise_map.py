"""
noise_map.py

This program is intended to generate a noise map for an RM cube, by fitting a Rayleigh distribution
to the wings of the RM spectra where there is little/no signal expected.

Right now, it does so on a pixel-by-pixel basis. It's not clear yet if it would be better to
smooth things over several pixels, maybe the beam size. Significant variations in the fit
over single pixels is unrealistic...

Adapted from code by Chris Riseley
"""

from pathlib import Path

import numpy as np
from astropy.io import fits
from astropy.wcs import WCS
from matplotlib import pyplot as plt
from scipy.optimize import curve_fit


def rayleigh(x, sigma):
    """Rayleigh distribution.

    Parameters
    ----------
    x : array
        Input numpy array
    sigma : int
        Scale parameter

    Returns
    -------
    numpy array
        Rayleigh probability distribution function
    """

    return (x / (sigma ** 2)) * np.exp(-(x ** 2) / (2 * sigma ** 2))


def gaussian(x, sigma):
    """Gaussian distribution.

    Parameters
    ----------
    x : array
        Input numpy array
    sigma : int
        Standard deviation

    Returns
    -------
    numpy array
        Gaussian probability distribution function
    """

    return (1.0 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-(x ** 2) / (2 * sigma ** 2))


# At one point I tested fitting Gaussians to Stokes Q/U instead of a Rayleigh to I, because Jamie Farnes
# and I had an arugment over which was better. Both were equivalent, as I expected. (Take that, Jamie!)


def noise_map(phi_mask, cuffs_prefix, cube_dir, plot=False):
    """Create noise map from RM fits cube.

    Noise maps are created from polarized intensity
    `P` RM cubes, generated by cuFFS having faraday
    depth as the first axis.

    A region around ùúô = 0 is masked out, as it is
    dominated by instumental leakage. The remaining
    data is histogrammed along the ùúô axis and fit with
    a rayleigh distribution, the peak of which is used
    as the noise value of the pixel.

    Parameters
    ----------
    phi_mask : int/float
        Mask the region around ùúô = 0 between ¬± phi_mask
    cuffs_prefix : str
        Prefix to cube names as defined in cuFFS parset file
    cube_dir: str
        Path to directory with rm cubes

    Returns
    -------
        FITS noise image and sample noise spectra from center
        of image, saved to cube_dir
    """

    p_cube = Path(f"{cube_dir}/{cuffs_prefix}p.phi.dirty.fits")
    print(f"Processing {p_cube}")

    # Extract header and data from fits cube
    with fits.open(p_cube, memmap=True, mode="denywrite") as hdus:
        hdu = hdus[0]
        hdr = hdu.header
        data = hdu.data

        # World Coordinate System
        wcs = WCS(hdr)

        # Determine the phi range from the header
        # Here, the order of indexing the same as the fits file
        # wcs.all_pix2world(ùúô, ‚ç∫, Œ¥, 0)
        # The last 0 ensures pythonic zero indexing
        phi_range, _, _ = wcs.all_pix2world(np.arange(data.shape[2]), 0, 0, 0)

    # Array of phi values to exclude
    # Define exclusion region (where real polarization / leakage can occur)
    phi_exc = np.arange(-1 * phi_mask, phi_mask + hdr["CDELT1"], hdr["CDELT1"])

    # Mask array with False at indicies of phi_exc
    phi_mask = np.array([False if p in phi_exc else True for p in phi_range])

    # Data array from rm cube fits file has order: [Œ¥, ‚ç∫, ùúô]
    # With N1: ùúô, N2: ‚ç∫, N3: Œ¥ in the header
    # We're now going to make a noise array with data order:[‚ç∫, Œ¥]
    # This way, for the new header, N2 can remain ‚ç∫, while N1 is changed to Œ¥ and N3 deleted

    # Instantiate placeholder noise array
    noise = np.zeros([data.shape[1], data.shape[0]])

    # Loop over RA
    for i in range(data.shape[1]):

        # Loop over Dec
        for j in range(data.shape[0]):

            #  print(
            #  f" ** INFO: Fitting noise Ra: {i}/{data.shape[1]}, Dec ind:{j}/{data.shape[0]}"
            #  )

            # Extract RM Spectra for RA, Dec
            rm_spec = data[j, i, :]

            # Mask |ùúô| < 20 where leakage dominates
            rm_masked = rm_spec[phi_mask]

            # For pixels in the primary beam nulls
            if np.sum(rm_masked) == 0:
                noise[i, j] = 0
                continue

            hist, edges = np.histogram(
                rm_masked, range=(np.amin(rm_masked), np.amax(rm_masked)), bins=30
            )

            # Bin centers
            bin_c = edges[:-1] + 0.5 * (edges[1] - edges[0])

            # Convert to probably density, area integrates to 1
            density = hist / (rm_masked.size * (edges[1] - edges[0]))
            sigma = np.sqrt(np.fmax(hist, 1) * (1 - hist / rm_masked.size)) / (
                rm_masked.size * (edges[1] - edges[0])
            )
            # A note on this last line: I calculate the error on the bin values using Poisson statistics,
            # but I add a 'robustness' correction (probably not rigourously correct) where if a bin has zero values
            # I assign it an error equivalent to if it had 1 entry.
            # This prevents bins from having an error of zero, which screws up the fit.

            #  plt.errorbar(bin_c, density, yerr=sigma, fmt='bo', linewidth=3)

            try:
                popt, pcov = curve_fit(rayleigh, bin_c, density, sigma=(1 / sigma))
            except Exception:
                #  If the fit fails, I give it an error of zero. I haven't seen this happen in any of my maps,
                #  so I think it is working reliably in that regard
                popt = [0]

            #  print(f"Noise: {popt[0]}, {np.sqrt(pcov[0])}")
            noise[i, j] = np.abs(popt[0])

            # Plot a sample noise fit of a pixel at the center of the image
            if plot is True:
                if i == int(round(data.shape[1] / 2)) and j == int(
                    round(data.shape[0] / 2)
                ):
                    print(" ** INFO: Writing noise fit plot")
                    plt.style.use("seaborn")
                    plt.hist(
                        rm_masked,
                        30,
                        density=True,
                        color="#ef8d32",
                        alpha=0.8,
                        edgecolor="#cc561edd",
                        linewidth=0.8,
                        label="Density",
                    )
                    plt.plot(
                        bin_c, rayleigh(bin_c, *popt), color="#28527a", label="Rayleigh"
                    )
                    plt.xlabel("RM bins [rad/m^2]")
                    plt.title("RM Spectra Noise Histogram and Fit")
                    plt.ylabel("Count")

                    leg = plt.legend(frameon=True, markerscale=1, handlelength=1)
                    leg.get_frame().set_facecolor("white")
                    for le in leg.legendHandles:
                        le.set_alpha(1)

                    plt.tight_layout()
                    plt.savefig(f"{cube_dir}/{cuffs_prefix}noise_fit_cen.png", dpi=300)

    # Create FITS header for noise map, save map to file.
    print(" ** INFO: Writing output noise image")
    new_header = hdr
    new_header["NAXIS"] = 2
    new_header.set("CRVAL1", hdr["CRVAL3"])
    new_header.set("CDELT1", hdr["CDELT3"])
    new_header.set("CRPIX1", hdr["CRPIX3"])
    new_header.set("CTYPE1", hdr["CTYPE3"])
    new_header.set("NAXIS1", hdr["NAXIS3"])
    del new_header["CTYPE3"]
    del new_header["CRVAL3"]
    del new_header["CDELT3"]
    del new_header["CRPIX3"]
    del new_header["NAXIS3"]

    hdul = fits.PrimaryHDU(data=noise, header=new_header)
    hdul.writeto(f"{cube_dir}/{cuffs_prefix}cube_noise.fits")

    #  chi_sq = np.sum((rayleigh(bin_c, popt[0]) - density) ** 2 / sigma ** 2)
    #  print(f"Chisq:, {chi_sq}, {chi_sq/(len(hist)-1)}")


if __name__ == "__main__":

    import argparse

    #####################################################################
    #                                                                   #
    #                            Get arguments                          #
    #                                                                   #
    #####################################################################

    parser = argparse.ArgumentParser(
        description="Create noise map from cuFFS fits cube"
    )

    parser.add_argument(
        "--phi_mask",
        metavar="\b",
        default=20,
        type=int,
        help="Central faraday depth region to mask. Default: ¬±20",
    )

    parser.add_argument(
        "--cuffs_prefix",
        metavar="\b",
        default="rts_imgr_",
        help="Prefix to cube names as defined in cuFFS parset file. Default=rts_imgr_",
    )

    parser.add_argument(
        "--cube_dir",
        metavar="\b",
        required=True,
        help="Path to dir with cuffs fits cubes",
    )

    parser.add_argument(
        "--plot",
        action="store_true",
        help="<FLAG> - Plot a sample noise fit of a pixel at the center of the image",
    )

    args = parser.parse_args()

    noise_map(args.phi_mask, args.cuffs_prefix, args.cube_dir, plot=args.plot)
